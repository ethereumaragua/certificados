{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call. This account bears the admin role (for the granted role).\n     * Expected in cases where the role was granted using the internal {AccessControl-_grantRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/Admin.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\ncontract Admin is AccessControl  {\n\n  struct EstructuraAdmin {\n    uint indice;\n    string nombre;\n  }\n\n  address[] public arregloAdmins;\n\n  mapping(address => EstructuraAdmin) public mapAdmin;\n\n  event LogAdminCreado(address cuenta, string nombre);\n  event LogAdminEliminado(address cuenta, string nombre);\n  event LogAdminNombreModificado(address cuenta, string nombreAnterior, string nombreNuevo); \n  event LogAdminCuentaModificada(address cuentaAnterior, address cuentaNueva);\n\n  bytes32 public constant ADMIN = keccak256(\"ADMIN\");\n\n  constructor() {\n        // DEFAULT_ADMIN_ROLE es el rol de super administrador predeterminado\n        // este podrá otorgar y revocar cualquier rol.\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        crearAdmin(msg.sender, \"SUPER_ADMIN\");\n    }\n\n  function esAdmin(address cuenta)\n    public view\n    returns(bool)\n  {\n    return hasRole(ADMIN, cuenta);\n  }\n\n  function crearAdmin(address admin, string memory nombre)\n    public onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    require(!hasRole(ADMIN, admin), \"Cuenta ya posee rol ADMIN\");\n    require(admin != address(0), \"Cuenta admin no puede ser address 0\");\n    mapAdmin[admin].nombre = nombre;\n    mapAdmin[admin].indice = arregloAdmins.length;\n    arregloAdmins.push(admin);\n    _grantRole(ADMIN, admin);\n    emit LogAdminCreado(admin, nombre);\n  }\n\n  function removerAdmin(address admin)\n    external onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    require(hasRole(ADMIN, admin), \"Cuenta no posee rol ADMIN\");\n    _revokeRole(ADMIN, admin);\n    EstructuraAdmin memory filaAEliminar = mapAdmin[admin];\n    address ultimoAdmin = arregloAdmins[arregloAdmins.length - 1];\n    arregloAdmins[filaAEliminar.indice] = ultimoAdmin;\n    mapAdmin[ultimoAdmin].indice = filaAEliminar.indice;\n    arregloAdmins.pop();\n    emit LogAdminEliminado(admin, filaAEliminar.nombre);\n  }\n\n  function modificarNombreAdmin(\n        address admin,\n        string calldata nombreNuevo)\n    public onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    require(hasRole(ADMIN, admin), \"Admin no existe\");\n    string memory nombreAnterior = mapAdmin[admin].nombre;\n    mapAdmin[admin].nombre = nombreNuevo;\n    emit LogAdminNombreModificado(admin, nombreAnterior, nombreNuevo);\n  }\n\n  function modificarCuentaAdmin(\n        address cuentaAnterior,\n        address cuentaNueva)\n    public onlyRole(DEFAULT_ADMIN_ROLE)\n  {\n    require(hasRole(ADMIN, cuentaAnterior), \"Admin no existe\");\n    EstructuraAdmin memory datosAnteriores = mapAdmin[cuentaAnterior];\n    mapAdmin[cuentaNueva].indice = datosAnteriores.indice;\n    mapAdmin[cuentaNueva].nombre = datosAnteriores.nombre;\n    arregloAdmins[datosAnteriores.indice] = cuentaNueva;\n    _revokeRole(ADMIN, cuentaAnterior);\n    _grantRole(ADMIN, cuentaNueva);\n    emit LogAdminCuentaModificada(cuentaAnterior, cuentaNueva);\n  }\n\n  function mostrarAdmins()\n    public view\n    returns(address[] memory, string[] memory)\n  {\n    string[] memory nombres = new string[](arregloAdmins.length);\n    for (uint i = 0; i < arregloAdmins.length; i++) {\n        nombres[i] = mapAdmin[arregloAdmins[i]].nombre;\n    }\n    return (arregloAdmins, nombres);\n  }\n}"
    },
    "contracts/Certificados.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Cursos.sol\";\nimport \"./Paises.sol\";\n\ncontract Certificados is Cursos {\n\n  event LogCertificado(Pais pais, uint usuario, string nombre, uint categoria, uint curso, address certificador, uint indexed idCertificado, uint fecha, string nombreCertificador);\n  event LogCertificadoEliminado(Pais pais, uint usuario, uint categoria, uint curso, address certificador);\n\n  uint certificadoContador;\n\n  struct EstructuraCursoUsuario {\n    uint categoria;\n    uint curso;\n    uint idCertificado;\n  }\n\n  struct EstructuraUsuario {\n    EstructuraCursoUsuario[] arregloCursosUsuario;\n    string nombre;\n  }\n\n  mapping(Pais => mapping(uint usuario => EstructuraUsuario)) public mapUsuario;\n\n  function datosYCertificadosUsuario(Pais pais, uint usuario) public view returns (EstructuraCursoUsuario[] memory, string memory) {\n    return (mapUsuario[pais][usuario].arregloCursosUsuario, mapUsuario[pais][usuario].nombre);\n  }\n\n  function estaCertificadoId(Pais pais, uint usuario, uint categoria, uint curso)\n    public view\n    returns (bool)\n  {\n    require(mapCurso[categoria][curso].certificador != address(0), \"Curso no existe\");\n    EstructuraCursoUsuario[] memory cursos =  mapUsuario[pais][usuario].arregloCursosUsuario;\n    for (uint i = 0; i < cursos.length; i++)\n    {\n      if(cursos[i].categoria == categoria && cursos[i].curso == curso)\n        return true;\n    }\n    return false;\n  }\n\n  function certificarId(Pais[] calldata paises, uint[] calldata idUsuarios, string[] calldata nombres, uint categoria, uint curso, string calldata nombreCertificador) public {\n    require(msg.sender == mapCurso[categoria][curso].certificador, \"No autorizado para este curso\");\n    require(mapCurso[categoria][curso].activo, \"Curso no activo\");\n    for (uint i = 0; i < idUsuarios.length; i++)\n    {\n      _certificarId(paises[i], idUsuarios[i], nombres[i], categoria, curso, nombreCertificador);\n    }\n  }\n\n  function _certificarId(Pais pais, uint usuario, string memory nombre, uint categoria, uint curso, string memory nombreCertificador) internal {\n    if(!estaCertificadoId(pais, usuario, categoria, curso)) {\n      mapUsuario[pais][usuario].arregloCursosUsuario.push(EstructuraCursoUsuario({categoria: categoria, curso: curso, idCertificado: certificadoContador}));\n      if(keccak256(abi.encodePacked(mapUsuario[pais][usuario].nombre)) != keccak256(abi.encodePacked(nombre)))\n        mapUsuario[pais][usuario].nombre = nombre;\n      emit LogCertificado(pais, usuario, nombre, categoria, curso, msg.sender, certificadoContador, block.timestamp, nombreCertificador);\n      certificadoContador++;\n    }\n  }\n\n  function eliminarCertificadoId(Pais pais, uint usuario, uint categoria, uint curso) public {\n    require(msg.sender == mapCurso[categoria][curso].certificador, \"No autorizado para este curso\");\n    require(estaCertificadoId(pais, usuario, categoria, curso), \"Usuario no certificado en este curso\");\n    require(mapCurso[categoria][curso].certificador != address(0), \"Curso no existe\");\n    EstructuraCursoUsuario[] memory cursos = mapUsuario[pais][usuario].arregloCursosUsuario;\n    bool encontrado = false;\n    for(uint i = 0; i < cursos.length; i++) {\n      if(cursos[i].categoria == categoria && cursos[i].curso == curso)\n      {\n        encontrado = true;\n        mapUsuario[pais][usuario].arregloCursosUsuario[i] = cursos[cursos.length - 1];\n        mapUsuario[pais][usuario].arregloCursosUsuario.pop();\n        emit LogCertificadoEliminado(pais, usuario, categoria, curso, msg.sender);\n      }\n    }\n    require(encontrado, \"Curso no encontrado\");\n  }\n\n  event LogCertificadoAddress(address usuario, string nombre, uint categoria, uint curso, address certificador, uint indexed idCertificado, uint fecha, string nombreCertificador);\n  event LogCertificadoEliminadoAddress(address usuario, uint categoria, uint curso, address certificador);\n\n  mapping(address usuario => EstructuraUsuario) public mapUsuarioAddress;\n\n  function certificarAddress(address[] calldata usuarios, string[] calldata nombres, uint categoria, uint curso, string calldata nombreCertificador) public {\n    require(msg.sender == mapCurso[categoria][curso].certificador, \"No autorizado para este curso\");\n    require(mapCurso[categoria][curso].activo, \"Curso no activo\");\n    for (uint i = 0; i < usuarios.length; i++)\n    {\n      _certificarAddress(usuarios[i], nombres[i], categoria, curso, nombreCertificador);\n    }\n  }\n\n  function _certificarAddress(address usuario, string memory nombre, uint categoria, uint curso, string memory nombreCertificador) internal {\n    if(!estaCertificadoAddress(usuario, categoria, curso)) {\n      mapUsuarioAddress[usuario].arregloCursosUsuario.push(EstructuraCursoUsuario({categoria: categoria, curso: curso, idCertificado: certificadoContador}));\n      if(keccak256(abi.encodePacked(mapUsuarioAddress[usuario].nombre)) != keccak256(abi.encodePacked(nombre)))\n        mapUsuarioAddress[usuario].nombre = nombre;\n      emit LogCertificadoAddress(usuario, nombre, categoria, curso, msg.sender, certificadoContador, block.timestamp, nombreCertificador);\n      certificadoContador++;\n    }\n  }\n\n  function eliminarCertificadoAddress(address usuario, uint categoria, uint curso) public {\n    require(msg.sender == mapCurso[categoria][curso].certificador, \"No autorizado para este curso\");\n    require(estaCertificadoAddress(usuario, categoria, curso), \"Usuario no certificado en este curso\");\n    require(mapCurso[categoria][curso].certificador != address(0), \"Curso no existe\");\n    EstructuraCursoUsuario[] memory cursos = mapUsuarioAddress[usuario].arregloCursosUsuario;\n    bool encontrado = false;\n    for(uint i = 0; i < cursos.length; i++) {\n      if(cursos[i].categoria == categoria && cursos[i].curso == curso)\n      {\n        encontrado = true;\n        mapUsuarioAddress[usuario].arregloCursosUsuario[i] = cursos[cursos.length - 1];\n        mapUsuarioAddress[usuario].arregloCursosUsuario.pop();\n        emit LogCertificadoEliminadoAddress(usuario, categoria, curso, msg.sender);\n      }\n    }\n    require(encontrado, \"Curso no encontrado\");\n  }\n\n  function estaCertificadoAddress(address usuario, uint categoria, uint curso)\n    public view\n    returns (bool)\n  {\n    require(mapCurso[categoria][curso].certificador != address(0), \"Curso no existe\");\n    EstructuraCursoUsuario[] memory cursos =  mapUsuarioAddress[usuario].arregloCursosUsuario;\n    for (uint i = 0; i < cursos.length; i++)\n    {\n      if(cursos[i].categoria == categoria && cursos[i].curso == curso)\n        return true;\n    }\n    return false;\n  }\n\n  function datosYCertificadosUsuarioAddress(address usuario) public view returns (EstructuraCursoUsuario[] memory, string memory) {\n    return (mapUsuarioAddress[usuario].arregloCursosUsuario, mapUsuarioAddress[usuario].nombre);\n  }\n}"
    },
    "contracts/Cursos.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Admin.sol\";\n\ncontract Cursos is Admin {\n\n  event LogCategoriaCreada(address admin, uint categoria, string nombre, bool estado);\n  event LogCursoCreado(address admin, uint categoria, uint curso, string nombreCurso, string descripcion, uint duracion, uint8 tipoCertificado, address certificador, bool activo);\n  event LogCursoModificado(address admin, uint categoria, uint curso, string nombreCurso, string descripcion, uint duracion, uint8 tipoCertificado, address certificador, bool activo);\n\n  struct EstructuraCategoria {\n    string nombre;\n    bool activa;\n  }\n  \n  EstructuraCategoria[] public arregloCategorias;\n\n  function crearCategoria(string calldata nombre) public onlyRole(ADMIN) {\n    uint categoria = arregloCategorias.length;\n    arregloCategorias.push(EstructuraCategoria({nombre: nombre, activa: true}));\n    arregloCursosPorCategoria.push(0);\n    emit LogCategoriaCreada(msg.sender, categoria, nombre, true);\n  }\n\n  function modificarCategoria(uint categoria, string calldata nombre, bool estado) public onlyRole(ADMIN) {\n    require(categoria < arregloCategorias.length, \"Categoria no existe\");\n    EstructuraCategoria memory registro = EstructuraCategoria({nombre: nombre, activa: estado});\n    arregloCategorias[categoria] = registro;\n    emit LogCategoriaCreada(msg.sender, categoria, nombre, estado);\n  }\n\n  function mostrarArregloDeCategorias()\n    public view\n    returns(EstructuraCategoria[] memory)\n  {\n    return arregloCategorias;\n  }\n\n  struct EstructuraCurso {\n    string nombreCurso;     // Nombre del curso\n    string descripcion;     // Descripcion del curso\n    uint duracion;          // Duracion del curso\n    uint8 tipoCertificado;  // Tipo de certificado\n    address certificador;   // Cuenta autorizada para certificar el curso\n    bool activo;            // Si el curso se encuentra activo o no\n  }\n\n  // Arreglo para almacenar cantidad de cursos que tiene cada categoria\n  uint[] public arregloCursosPorCategoria;\n\n  mapping(uint categoria => mapping(uint curso => EstructuraCurso)) public mapCurso;\n\n  function agregarCurso(uint categoria, string calldata nombreCurso, string calldata descripcion, uint duracion, uint8 tipoCertificado, address certificador, bool activo)\n    public onlyRole(ADMIN)\n  {\n    require(arregloCategorias[categoria].activa, \"Categoria no activa\");\n    require(certificador != address(0), \"Address certificador incorrecta\");\n    uint curso = arregloCursosPorCategoria[categoria];\n    mapCurso[categoria][curso] = EstructuraCurso({nombreCurso: nombreCurso, descripcion: descripcion, duracion: duracion, tipoCertificado: tipoCertificado, certificador: certificador, activo: activo});\n    arregloCursosPorCategoria[categoria]++;\n    emit LogCursoCreado(msg.sender, categoria, curso, nombreCurso, descripcion, duracion, tipoCertificado, certificador, activo);\n  }\n\n  function modificarCurso(uint categoria, uint curso, string calldata nombreCurso, string calldata descripcion, uint duracion, uint8 tipoCertificado, address certificador, bool activo)\n    public onlyRole(ADMIN)\n  {\n    require (mapCurso[categoria][curso].certificador != address(0), \"Curso no existe\");\n    require(certificador != address(0), \"Address certificador incorrecta\");\n    mapCurso[categoria][curso] = EstructuraCurso({nombreCurso: nombreCurso, descripcion: descripcion, duracion: duracion, tipoCertificado: tipoCertificado, certificador: certificador, activo: activo});\n    emit LogCursoModificado(msg.sender, categoria, curso, nombreCurso, descripcion, duracion, tipoCertificado, certificador, activo);\n  }\n\n  function mostrarArregloCursosPorCategoria() public view returns(uint[] memory) {\n    return arregloCursosPorCategoria;\n  }\n\n  function mostrarCantidadDeCursos()\n    public view\n    returns(uint)\n  {\n    uint cantidadDeCursos;\n    for(uint i = 0; i < arregloCursosPorCategoria.length; i++) {\n      cantidadDeCursos += arregloCursosPorCategoria[i];\n    }\n    return cantidadDeCursos;\n  }\n\n  function mostrarCategoriaYCurso(uint categoria, uint curso) public view returns (string memory, EstructuraCurso memory) {\n    return (arregloCategorias[categoria].nombre, mapCurso[categoria][curso]);\n  }\n}"
    },
    "contracts/Paises.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nenum Pais {\r\n    AFGANISTAN,\r\n    ALBANIA,\r\n    ALGERIA,\r\n    ANDORRA,\r\n    ANGOLA,\r\n    ANTIGUA_Y_BARBUDA,\r\n    ARGENTINA,\r\n    ARMENIA,\r\n    AUSTRALIA,\r\n    AUSTRIA,\r\n    AZERBAIJAN,\r\n    BAHAMAS,\r\n    BAHREIN,\r\n    BANGLADESH,\r\n    BARBADOS,\r\n    BELARUS,\r\n    BELGICA,\r\n    BELICE,\r\n    BENIN,\r\n    BHUTAN,\r\n    BOLIVIA,\r\n    BOSNIA_Y_HERZEGOVINA,\r\n    BOTSWANA,\r\n    BRASIL,\r\n    BRUNEI,\r\n    BULGARIA,\r\n    BURKINA_FASO,\r\n    BURUNDI,\r\n    CABO_VERDE,\r\n    CAMBOYA,\r\n    CAMERUN,\r\n    CANADA,\r\n    CHAD,\r\n    CHILE,\r\n    CHINA,\r\n    CHIPRE,\r\n    COLOMBIA,\r\n    COMORAS,\r\n    CONGO,\r\n    COREA_DEL_NORTE,\r\n    COREA_DEL_SUR,\r\n    COSTA_DE_MARFIL,\r\n    COSTA_RICA,\r\n    CROACIA,\r\n    CUBA,\r\n    DINAMARCA,\r\n    DJIBOUTI,\r\n    DOMINICA,\r\n    ECUADOR,\r\n    EGIPTO,\r\n    EL_SALVADOR,\r\n    EMIRATOS_ARABES_UNIDOS,\r\n    ERITREA,\r\n    ESLOVAQUIA,\r\n    ESLOVENIA,\r\n    ESPANA,\r\n    ESTADOS_UNIDOS,\r\n    ESTONIA,\r\n    ETIOPIA,\r\n    FIJI,\r\n    FILIPINAS,\r\n    FINLANDIA,\r\n    FRANCIA,\r\n    GABON,\r\n    GAMBIA,\r\n    GEORGIA,\r\n    GHANA,\r\n    GRAN_BRETANA,\r\n    GRANADA,\r\n    GRECIA,\r\n    GUATEMALA,\r\n    GUINEA,\r\n    GUINEA_BISSAU,\r\n    GUINEA_ECUATORIAL,\r\n    HAITI,\r\n    HONDURAS,\r\n    HONG_KONG,\r\n    HUNGRIA,\r\n    INDIA,\r\n    INDONESIA,\r\n    IRAN,\r\n    IRAK,\r\n    IRLANDA,\r\n    ISLANDIA,\r\n    ISRAEL,\r\n    ITALIA,\r\n    JAMAICA,\r\n    JAPON,\r\n    JORDANIA,\r\n    KAZAJISTAN,\r\n    KENIA,\r\n    KIRGUISTAN,\r\n    KIRIBATI,\r\n    KUWAIT,\r\n    LESOTO,\r\n    LETONIA,\r\n    LIBANO,\r\n    LIBERIA,\r\n    LIBIA,\r\n    LITUANIA,\r\n    LUXEMBURGO,\r\n    MACAO,\r\n    MACEDONIA_DEL_NORTE,\r\n    MADAGASCAR,\r\n    MALASIA,\r\n    MALAWI,\r\n    MALDIVAS,\r\n    MALI,\r\n    MALTA,\r\n    MARRUECOS,\r\n    MARSHALL,\r\n    MAURICIO,\r\n    MAURITANIA,\r\n    MEXICO,\r\n    MICRONESIA,\r\n    MOLDAVIA,\r\n    MONACO,\r\n    MONGOLIA,\r\n    MONTENEGRO,\r\n    MOZAMBIQUE,\r\n    MYANMAR,\r\n    NAMIBIA,\r\n    NAURU,\r\n    NEPAL,\r\n    NICARAGUA,\r\n    NIGER,\r\n    NIGERIA,\r\n    NORUEGA,\r\n    NUEVA_ZELANDA,\r\n    OMAN,\r\n    PAISES_BAJOS,\r\n    PAKISTAN,\r\n    PALAU,\r\n    PANAMA,\r\n    PAPUA_NUEVA_GUINEA,\r\n    PARAGUAY,\r\n    PERU,\r\n    POLONIA,\r\n    PORTUGAL,\r\n    PUERTO_RICO,\r\n    QATAR,\r\n    REINO_UNIDO,\r\n    REPUBLICA_CENTROAFRICANA,\r\n    REPUBLICA_CHECA,\r\n    REPUBLICA_DEMOCRATICA_DEL_CONGO,\r\n    REPUBLICA_DOMINICANA,\r\n    RUMANIA,\r\n    RUSIA,\r\n    RWANDA,\r\n    SAHARA_OCCIDENTAL,\r\n    SAINT_KITTS_Y_NEVIS,\r\n    SAINT_LUCIA,\r\n    SAINT_VINCENT_Y_GRANADINAS,\r\n    SAMOA,\r\n    SAN_MARINO,\r\n    SANTO_TOME_Y_PRINCIPE,\r\n    SENEGAL,\r\n    SERBIA,\r\n    SEYCHELLES,\r\n    SIERRA_LEONA,\r\n    SINGAPUR,\r\n    SIRIA,\r\n    SOMALIA,\r\n    SRI_LANKA,\r\n    SUDAFRICA,\r\n    SUDAN,\r\n    SUDAN_DEL_SUR,\r\n    SUECIA,\r\n    SUIZA,\r\n    SURINAM,\r\n    SWAZILANDIA,\r\n    TAILANDIA,\r\n    TAIWAN,\r\n    TANZANIA,\r\n    TAYIKISTAN,\r\n    TIMOR_ORIENTAL,\r\n    TOGO,\r\n    TONGA,\r\n    TRINIDAD_Y_TOBAGO,\r\n    TUNEZ,\r\n    TURKMENISTAN,\r\n    TURQUIA,\r\n    TUVALU,\r\n    UCRANIA,\r\n    UGANDA,\r\n    URUGUAY,\r\n    UZBEKISTAN,\r\n    VANUATU,\r\n    VATICANO,\r\n    VENEZUELA,\r\n    VIETNAM,\r\n    YEMEN,\r\n    YIBUTI,\r\n    ZAMBIA,\r\n    ZIMBABUE,\r\n    OTRO\r\n  }"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}